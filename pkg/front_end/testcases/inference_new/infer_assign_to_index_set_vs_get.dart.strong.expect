library test;
import self as self;
import "dart:core" as core;

class Index extends core::Object {
  synthetic constructor •() → self::Index*
    : super core::Object::•()
    ;
}
class A extends core::Object {
  synthetic constructor •() → self::A*
    : super core::Object::•()
    ;
  operator +(self::F* v) → self::C*
    return null;
  operator -(core::int* i) → self::C*
    return null;
}
class B extends self::A {
  synthetic constructor •() → self::B*
    : super self::A::•()
    ;
  operator +(self::E* v) → self::D*
    return null;
  operator -(core::int* i) → self::D*
    return null;
}
class C extends self::B {
  synthetic constructor •() → self::C*
    : super self::B::•()
    ;
}
class D extends self::C {
  synthetic constructor •() → self::D*
    : super self::C::•()
    ;
}
class E extends self::D {
  synthetic constructor •() → self::E*
    : super self::D::•()
    ;
}
class F extends self::E {
  synthetic constructor •() → self::F*
    : super self::E::•()
    ;
}
class Test extends core::Object {
  synthetic constructor •() → self::Test*
    : super core::Object::•()
    ;
  operator [](self::Index* i) → self::B*
    return null;
  operator []=(self::Index* i, self::A* v) → void {}
  method test() → void {
    self::Test* t = self::f<self::Test*>();
    t.{self::Test::[]=}(self::f<self::Index*>(), self::f<self::A*>());
    let final self::Test* #t1 = t in let final self::Index* #t2 = self::f<self::Index*>() in #t1.{self::Test::[]}(#t2).{core::Object::==}(null) ?{self::A*} #t1.{self::Test::[]=}(#t2, self::f<self::A*>()) : null;
    let final self::Test* #t3 = t in let final dynamic #t4 = self::f<dynamic>() in #t3.{self::Test::[]=}(#t4 as{TypeError} self::Index*, #t3.{self::Test::[]}(#t4 as{TypeError} self::Index*).{self::B::+}(self::f<dynamic>() as{TypeError} self::E*));
    let final self::Test* #t5 = t in let final dynamic #t6 = self::f<dynamic>() in let final self::D* #t7 = #t5.{self::Test::[]}(#t6 as{TypeError} self::Index*).{self::B::-}(1) in let final void #t8 = #t5.{self::Test::[]=}(#t6 as{TypeError} self::Index*, #t7) in #t7;
    let final self::Test* #t9 = t in let final dynamic #t10 = self::f<dynamic>() in #t9.{self::Test::[]=}(#t10 as{TypeError} self::Index*, #t9.{self::Test::[]}(#t10 as{TypeError} self::Index*).{self::B::-}(1));
    self::A* v1 = let final self::Test* #t11 = t in let final self::Index* #t12 = self::f<self::Index*>() in let final self::A* #t13 = self::f<self::A*>() in let final void #t14 = #t11.{self::Test::[]=}(#t12, #t13) in #t13;
    self::A* v2 = let final self::Test* #t15 = t in let final self::Index* #t16 = self::f<self::Index*>() in let final self::B* #t17 = #t15.{self::Test::[]}(#t16) in #t17.{core::Object::==}(null) ?{self::A*} let final self::A* #t18 = self::f<self::A*>() in let final void #t19 = #t15.{self::Test::[]=}(#t16, #t18) in #t18 : #t17;
    self::D* v3 = let final self::Test* #t20 = t in let final dynamic #t21 = self::f<dynamic>() in let final self::D* #t22 = #t20.{self::Test::[]}(#t21 as{TypeError} self::Index*).{self::B::+}(self::f<dynamic>() as{TypeError} self::E*) in let final void #t23 = #t20.{self::Test::[]=}(#t21 as{TypeError} self::Index*, #t22) in #t22;
    self::D* v4 = let final self::Test* #t24 = t in let final dynamic #t25 = self::f<dynamic>() in let final self::D* #t26 = #t24.{self::Test::[]}(#t25 as{TypeError} self::Index*).{self::B::-}(1) in let final void #t27 = #t24.{self::Test::[]=}(#t25 as{TypeError} self::Index*, #t26) in #t26;
    self::B* v5 = let final self::Test* #t28 = t in let final dynamic #t29 = self::f<dynamic>() in let final self::B* #t30 = #t28.{self::Test::[]}(#t29 as{TypeError} self::Index*) in let final void #t31 = #t28.{self::Test::[]=}(#t29 as{TypeError} self::Index*, #t30.{self::B::-}(1)) in #t30;
  }
}
static method f<T extends core::Object* = dynamic>() → self::f::T*
  return null;
static method main() → dynamic {}
