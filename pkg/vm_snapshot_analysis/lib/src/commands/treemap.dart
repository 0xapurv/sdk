// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/// This tool creates interactive navigatable binary size reports from
/// JSON file generated by the AOT compiler's --print-instructions-sizes-to
/// flag.
///
/// It used the same visualization framework as Chromium's binary_size tool
/// located in runtime/third_party/binary_size.
library vm_snapshot_analysis.commands.treemap;

import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:isolate';
import 'dart:math' show max;

import 'package:path/path.dart' as p;
import 'package:args/command_runner.dart';

import 'package:vm_snapshot_analysis/instruction_sizes.dart'
    as instruction_sizes;
import 'package:vm_snapshot_analysis/program_info.dart';
import 'package:vm_snapshot_analysis/v8_profile.dart' as v8_profile;
import 'package:vm_snapshot_analysis/utils.dart';

class TreemapCommand extends Command<void> {
  @override
  final name = 'treemap';

  @override
  final description = '''
Create interactive treemap from snapshot profiling information.

This tool is used to process snapshot size reports produced by
--print-instructions-sizes-to and --write-v8-snapshot-profile-to flags.

It will create an interactive web-page in the output-directory which can be
viewed in a browser:

\$ google-chrome <output-directory>/index.html''';

  @override
  String get invocation => super
      .invocation
      .replaceAll('[arguments]', '<symbol-sizes.json> <output-directory>');

  TreemapCommand() {
    // [argParser] is automatically created by the parent class.
    argParser.addFlag('force',
        abbr: 'f',
        help: 'Force overwrite output directory even if it already exists');
  }

  @override
  Future<void> run() async {
    if (argResults.rest.length != 2) {
      usageException('Need to specify input JSON and output directory.');
    }

    final input = File(argResults.rest[0]);
    final outputDir = Directory(argResults.rest[1]);

    if (!input.existsSync()) {
      usageException('Input file ${input.path} does not exist!');
    }

    if (outputDir.existsSync() && !argResults['force']) {
      usageException(
          'Output directory ${outputDir.path} already exists, specify --force to ignore.');
    }

    await generateTreeMap(input, outputDir);
  }
}

Future<void> generateTreeMap(File input, Directory outputDir) async {
  // Load symbols data produced by the AOT compiler and convert it to
  // a tree.
  final inputJson = await loadJson(input);

  final root = {'n': '', 'children': {}, 'k': kindPath, 'maxDepth': 0};

  if (v8_profile.Snapshot.isV8HeapSnapshot(inputJson)) {
    treemapFromSnapshot(root, v8_profile.Snapshot.fromJson(inputJson));
  } else {
    final symbols = instruction_sizes.fromJson(inputJson);
    for (var symbol in symbols) {
      addSymbol(root, treePath(symbol), symbol.name.scrubbed, symbol.size);
    }
  }
  final tree = flatten(root);

  // Create output directory and copy all auxiliary files from binary_size tool.
  await outputDir.create(recursive: true);

  final assetsUri = await Isolate.resolvePackageUri(
      Uri.parse('package:vm_snapshot_analysis/src/assets'));
  final assetsDir = assetsUri.toFilePath();
  final d3SrcDir = p.join(assetsDir, 'd3', 'src');

  final d3OutDir = p.join(outputDir.path, 'd3');
  await Directory(d3OutDir).create(recursive: true);

  for (var file in ['LICENSE', 'd3.js']) {
    await copyFile(d3SrcDir, file, d3OutDir);
  }
  for (var file in ['index.html', 'D3SymbolTreeMap.js']) {
    await copyFile(assetsDir, file, outputDir.path);
  }

  // Serialize symbol size tree as JSON.
  final dataJsPath = p.join(outputDir.path, 'data.js');
  final sink = File(dataJsPath).openWrite();
  sink.write('var tree_data=');
  await sink.addStream(Stream<Object>.fromIterable([tree])
      .transform(json.encoder.fuse(utf8.encoder)));
  await sink.close();

  // Done.
  print('Generated ${p.toUri(p.absolute(outputDir.path, 'index.html'))}');
}

void treemapFromSnapshot(Map<String, dynamic> root, v8_profile.Snapshot snap) {
  final info = v8_profile.toProgramInfo(snap);

  final ownerPathCache = List<String>(info.snapshotInfo.infoNodes.length);
  ownerPathCache[info.root.id] = info.root.name;

  String nameOf(v8_profile.Node node) {
    switch (node.type) {
      case 'Library':
      case 'Class':
      case 'Function':
        return node.name;

      default:
        return '${node.type}';
    }
  }

  String ownerPath(ProgramInfoNode n) {
    return ownerPathCache[n.id] ??=
        ((n.parent != info.root) ? '${ownerPath(n.parent)}/${n.name}' : n.name);
  }

  for (var node in snap.nodes) {
    if (node.selfSize > 0) {
      final owner = info.snapshotInfo.ownerOf(node);
      final path = ownerPath(owner);
      final name = nameOf(node);
      addSymbol(root, path, name, node.selfSize,
          symbolType: node.type == '(RO) Instructions'
              ? symbolTypeGlobalText
              : symbolTypeGlobalInitializedData);
    }
  }
}

/// Returns a /-separated path to the given symbol within the treemap.
String treePath(instruction_sizes.SymbolInfo symbol) {
  if (symbol.name.isStub) {
    if (symbol.name.isAllocationStub) {
      return '@stubs/allocation-stubs/${symbol.libraryUri}/${symbol.className}';
    } else {
      return '@stubs';
    }
  } else {
    return '${symbol.libraryUri}/${symbol.className}';
  }
}

const kindSymbol = 's';
const kindPath = 'p';
const kindBucket = 'b';
const symbolTypeGlobalText = 'T';
const symbolTypeGlobalInitializedData = 'D';

/// Create a child with the given name within the given node or return
/// an existing child.
Map<String, dynamic> addChild(
    Map<String, dynamic> node, String kind, String name) {
  return node['children'].putIfAbsent(name, () {
    final n = <String, dynamic>{'n': name, 'k': kind};
    if (kind != kindSymbol) {
      n['children'] = {};
    }
    return n;
  });
}

/// Add the given symbol to the tree.
void addSymbol(Map<String, dynamic> root, String path, String name, int size,
    {String symbolType = symbolTypeGlobalText}) {
  var node = root;
  var depth = 0;
  for (var part in path.split('/')) {
    node = addChild(node, kindPath, part);
    depth++;
  }
  node['lastPathElement'] = true;
  node = addChild(node, kindBucket, symbolType);
  node['t'] = symbolType;
  node = addChild(node, kindSymbol, name);
  node['t'] = symbolType;
  node['value'] = (node['value'] ?? 0) + size;
  depth += 2;
  root['maxDepth'] = max<int>(root['maxDepth'], depth);
}

/// Convert all children entries from maps to lists.
Map<String, dynamic> flatten(Map<String, dynamic> node) {
  dynamic children = node['children'];
  if (children != null) {
    children = children.values.map((dynamic v) => flatten(v)).toList();
    node['children'] = children;
    if (children.length == 1 && children.first['k'] == 'p') {
      final singleChild = children.first;
      singleChild['n'] = '${node['n']}/${singleChild['n']}';
      return singleChild;
    }
  }
  return node;
}

/// Copy file with the given name from [fromDir] to [toDir].
Future<void> copyFile(String fromDir, String name, String toDir) async {
  await File(p.join(fromDir, name)).copy(p.join(toDir, name));
}
